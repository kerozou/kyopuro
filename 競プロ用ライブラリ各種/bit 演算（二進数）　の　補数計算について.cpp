// bit 演算（二進数）　の　補数計算について
// http://www1.cts.ne.jp/~clab/hsample/Bit/Bit3.html 参考

bit演算で登場しがちな　-　についてまとめておく

3 は　00000011 であり、 -3 は　11111101 である。
つまり、3 をbit反転させた　~3 = 11111100　に 1 を加えると　-3 になることになる。

この操作のことを、3について「 2 の補数を求める」という。
コンピュータはこのような方法で、マイナスの値を内部表現している。

これを受けて、一般化してみる。
例えば、ある数を考えてみるとき、ある数は

    1.末尾０
    2.末尾１

の二通りで尽くせる。

　1,の時（末尾０）
    反転して1足したとき、末尾の0bit目は０、1bit目以降は繰り上がるをくりかえし、いずれ１になりとまる。
    つまり、負の数は末尾0で、次に登場する1までは全部0ということになる。
    このとき、元の数字と負の数は最初に登場する1の位置が等しくなるという性質が導かれる。
    また、bit反転をしているので、1がともに登場する桁は高々１つということになる。
    実際に適当な数字で試してみるとよい。

　2,の時（末尾１）
    反転して1足したとき、末尾は1で,1bit目以降はそのままとなる。
    つまり、0ｂit目は元の数も、負の数も1になり、初めて登場する1は０桁目ということになる。
    こちらも同様に、bit反転をしているので、1がともに登場する桁は高々１つということになる。

以上の2点を考えるとき、導かれる結論は

    元の数　＆　負の数　＝　初めて登場する1がbitに1つあるだけの数

つまり、000100　のような 2^x であることがわかる。
2^x は2進数の都合、もともと1が立っている場所から引くには都合がいい。

なので、BIT（BinaryIndexedTree)のsum処理的には、末尾の1をサーチして順に足していくことが可能になり、扱いやすいということ。