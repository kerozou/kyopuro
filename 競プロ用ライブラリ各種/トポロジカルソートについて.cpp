// トポロジカルソートについて

トポロジカルソートは　N頂点　M辺　の有向グラフG　の　「有向閉路がない」ものを一方向に進めるように並べるソート。（というか、一意になるわけではないから、厳密にはソートっぽくなさそうな感覚）
ちなみに有向閉路を持たないグラフは　DAG　という。（Directed Acyclic Graph)

また、トポロジカルソートができる　≡　DAGである。

必要なものは、
・有向グラフ（入力）
・入次数のリスト（やってくる元の本数）

である。

これを、メモ化再帰　または　BFS　で用意する？
以下ではおそらくBFSで、計算量はO(V+E)

//

//グラフの隣接リスト
vector<int> G(100010);

//頂点の入次数
vector<int> h(100010);

int main(){
    //頂点数v、辺の数e
    int v,e;
    cin >> v >> e;
    rep(i,e){
        int s,t;
        cin >> s >> t;  // ２頂点からグラフ作成
        G[s].push_back(t);
        h[t]++; //入++
    }

    //入が0の頂点キュー
    queue<int> zero();

    //入をいれてく
    rep(i,v)if(h[i] == 0)zero.push(i);

    //ソート後のグラフ配列
    vector<int> ans;

    while(zero.size()){
        //zeroから一つとる
        int i = zero.front();zero.pop();
        ans.push_back(i);
        for(auto &j : G[i]){
            //隣接頂点の入を-1
            h[j]--;
            //これで入が0になればキューにつっこむ
            if(h[j] == 0)zero.push(j);
        }
    }

    //ansを順に出力するとトポロジカルソート後のグラフというか、頂点の列が得られる。
    for(int i : ans)cout << i << endl;

}




// EDPC-G LongestPath にて

// DAGなので、トポロジカルソート後の入次数0の頂点から右に進んで、dp[i]:= 頂点iが終点としたときにの最長の長さ　とおけば、
// chmax(dp[nv],dp[v]+1) とすればいい。　(nvは頂点vから刺さる先の頂点)
// これを考えてみると、vからスタートすると、vは0、nvは１になって・・・・・・と更新が続いていく。
// 結局、入次数0 の頂点からスタートして、進むごとに辺を消去していくので入次数0の頂点を次々と始点としてループしていけば、いずれすべてのルートを通りつくす。
// このとき、一度通った流れはdpに記録されているので、その経路を別から通った時には大きくなるほうにchangeしていく。
// 例としては、 0→1→2→3→4 5→6   h[]は入り次数
//             ↓→→→→→↑ ↓→→→↑
// とあったら、０から始まって、dp[1] = 1 , dp[3] = 1, h[1] = 0 →　dp[2] = 2 h[2] = 0 → chmax(dp[3],dp[2]+1) で dp[3] = 1, dp[2]+1 = 3　なので dp[3] = 3に更新
//                          dp[4] = dp[3]+1 = 4 , dp[6] = dp[4]+1 = 5, chmax(dp[6],dp[5]+1) だけど、dp[5]+1 = 1 なので、dp[6] = 5 が採用。
// よって、dpは [1] = 1
//             [2] = 2
//             [3] = 3
//             [4] = 4
//             [5] = 1
//             [6] = 5
// となる。
// なので、repなり、max_elementなりすれば ans = 5 となる。
// つまり、上の矢印のDAGを作ったあとは、chmaxの回数は結局辺の数になっている。
// よって、トポロジカルソートはO(V+E)なので、全体での計算量は O(V+E+E)になっているような気がする。

// トポロジカルソートをしないと、
//             ↓←←←←←←←←←↑
// 例としては、 0→1→2→3→4 5→6   
//             ↓→→→→→↑ ↓→→→↑

// みたいに、後ろに戻っちゃうやつがでてきたら困るから？こうなると、DPを頭からやっていって答えが一意になる保証がなくなる。
// 仮に上の例だと、トポロジカルソートすると、
//             ↑→→→→→→→→→→→↓
//             5→0→1→2→3→4→6
//               ↓→→→→→↑
// みたいになって確かに、DPしていける感じになる。

// つまり、トポロジカルソートの便利なところは、巡回したり、遷移がややこしかったりする有向グラフがDAGにできるときにDPなり全探索なりをしやすくできる点だと考えられる。



EDPC－Gを受けて

// 結局うまく理解できないので、質問コーナーを参照したところ、
// キューは最長距離が短い順に入っていくので、最後に一回chmaxするだけでも問題ないということだった。
// スタックで毎回更新しないとやばい例を下に記す。
//  
//             ↑→→→→→→→→→→→→→→→→→→→→→↓
//             5→0→1→2  7→10→9→8→3→4→6
//               ↓→→→→→→→→→→→→→→→↑

// みたいなときに、仮に7スタートで行ったとしたとき、dp[8]=3 なのに、dp[3]は0からルートがあるので、入次数0 にならずchmaxが挟まらないことに。
// このとき、後からやってきた503のルートだと、dp[3] = 2　になって最大ルートの大きさは4になっておかしい。ということ。


全国統一プログラミング王決定戦予選の　D - Restore the Tree　がトポロジカルソートの問題