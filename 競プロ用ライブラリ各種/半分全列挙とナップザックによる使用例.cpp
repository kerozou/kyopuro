// 半分全列挙について

半分全列挙とは、ループ長がNになるときに、N個では全探索できないが、N/2個ならば間に合うときに有効な全列挙法。
例えば、N=40の時に、O(2^N)は間に合わないが、O(2^(N/2))ならば間に合う。
また、N=1000の時に、O(N^4)は間に合わないが、O(N^2)ならば間に合うといった様子。

・具体的にどんな風に有効なのか？
    1.まず、全探索したい集合を2つの集合A,Bに分ける。
    2.それぞれについて、全探索したものをリスト化しておく。
    3.全探索リストAをkeyとして、Bに関して二分探索を行うなど、O(logN)などの計算量を落とせる手法を使えないか模索する。

    という手順になる。
    二分探索はソート後に使えるので、O(NlogN)操作が加わったとしても、全体として、O(2^(N/2)*N) log(N/2)≒O(N)としている 計算量になる。

・半分全列挙でナップザックを解いてみる。
AtCoder Beginner Contest 032 - D ナップサック問題　を解く。
この問題は、
    1.N=30以下
    2.重さ制限
    3.価値制限
の3種類のケースに分類されて、それぞれが通ればいい。
この時、2,3に関しては、基本的なナップザックDPで解ける。
しかし、1に関しては、重さと価値の値が10^9となっており、O(NW)、O(NV)では解けないようになってる。
なので、Nに関する全探索系で攻めなければならないが、2^30 > 10^9 なので、厳しい。

というわけで、1に関して半分全列挙を使えば 2^15 ≒ 30000　程度まで計算量を落とせる。
なので、半分にした後の集合に重さで二分探索、そして価値についてソートが適用できれば、全体の計算量は O(2^(N/2)*log(N/2)*NlogN) ≒ O(2^(N/2)*N)つまり、30000*30=9.0*10^5 ≒ 10^6 程度まで落とせる。

というわけで、1について解いてみたい。
自作なので、だいぶ汚いが下のようになるはず。

int main(){
    // 入力
    int N;cin >> N;
    LL W;cin >> W;
    vector<LL> w(N);
    vector<LL> v(N);
    rep(i,N)cin >> v[i] >> w[i];

if(N <= 30){

    vector<int> bit_flag(30);
    rep(i,30){
        bit_flag[i] = (1 << i);
    }

    // 半分集合の前半
    int sz = N/2;
    int lim = (1 << sz);
    vector<pll> A(lim);
    for(int bit = 0;bit < (1 << sz);bit++){
        LL weight = 0;
        LL value = 0;
        rep(i,sz){
            if(bit & bit_flag[i]){
                weight += w[i];
                value += v[i];
            }
        }
        A[bit] = make_pair(weight,value);
    }


    // 無駄な部分を省く(この流れが天才すぎる)
    sort(all(A));
    int m = 1;
    rep(i,lim)if(A[m-1].S < A[i].S)A[m++] = A[i];       
    
    // if内でソート済み連番を比較して、w[i]<w[j] ^ v[i]>v[j] なる雑魚いやつを全部前へ前へ詰めていってる。
    // つまり、(2,3)(2,4)(2,4)(2,5)(3,1)(3,2)(3,6) ってあったら、(2,4)被りで一回mが止まり、1個ずれたiが(2,5)を前に押し出す。
    // (2,5)から(3,6)までは、(3,1)(3,2)が押しつぶされて消える。
    // 最終的に残るのは、(2,3)(2,4)(2,5)(3,6)だけになる。
    // このとき、この7組でやったとしたら、m=1は3回インクリメントされて、m=4になる。このmは後半の二分探索のイテレータ指定に使う。
    


    /////////////////////////////////////////////
    // 半分集合の後半
    int sz2 = (N - (N/2) );
    int lim2 = (1 << sz2);
    LL ans = 0;
    for(int bit = 0;bit < (1 << sz2);bit++){
        LL weight = 0;
        LL value = 0;
        rep(i,sz2){
            if(bit & bit_flag[i]){
                weight += w[i+N/2];     // N/2 を足すのは、全体集合を二つに分けているから
                value += v[i+N/2];
            }
        }
        if(weight <= W){
            LL temp_v = (lower_bound(A.begin(),A.begin()+m,make_pair(W - weight,INF)) -1) -> S;     // (2,5)(2,6)(2,7)(3,9)とあったら、lower_boundは(3.9)のitrを返すので、それから-1したものが求めたいもの。
            ans = max(ans,value + temp_v);
        }
    }
    cout << ans << endl;
}
}