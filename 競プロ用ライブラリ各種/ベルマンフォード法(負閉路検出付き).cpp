// ベルマンフォード法
// 使用前に　グラフG　と　最短距離配列D　をリサイズする必要あり
// 頂点の数をV、辺の数をEとした場合、計算量はO(|V||E|)

// 負閉路検出は使用後に各Dを調べて　MINF　の時そこに至るまでに負閉路を通過している。

// http://sigma1113.hatenablog.com/entry/2019/08/12/130042
// ここがわかりやすかった

// 使用時の注意点として、普通のグラフを扱う時同様、ノードの番号はあらかじめ -- してからグラフ化しておくとよさそう。

// ベルマンフォードは　スタート地点　から各点への最短距離を　D　に格納する。

// 使用例
// ABC137 E - Coins Respawn
// ABC061 D - Score Attack

// 負閉路検知はいろいろいじると正閉路検知にしたりできるぞ
//（というより、正閉路検知と負閉路検知が混ざると厄介なので、
// 基本的に重みを*-1して最後にもう一回*-1することで実現してるっぽい)


typedef struct Edge{
    int from;
    int to;
    LL cost;
}Edge;

vector<Edge> G; // グラフ
vector<LL> D;   // 各ノードへの最短距離
int N;  // N:頂点数
#define MINF -1000000000000000000

void Bellman_Ford(int a){   // a はスタート地点
    rep(i,N)D[i] = INF;
    D[a] = 0;   // 初期地点
    rep(i,N){   // N回繰り返すだけなので、indexは気にしない(頂点数)
        for(auto j : G){
            if(D[j.from] != INF && D[j.to] > D[j.from] + j.cost)D[j.to] = D[j.from] + j.cost;
        }
    }
}


// Bellman_Ford後に使用
void Nega_Search(){     // 負閉路を検知すると、その閉路に関わるノードのDを-INFに書き換える
    rep(i,N){
        for(auto j : G){
            if(D[j.to] != INF && D[j.to] > D[j.from] + j.cost)D[j.to] = MINF;
        }
    }
}








// Bellman_Ford の個人的見解

/*
    ・各頂点を順に深さ優先探索で進んでいき、各ノードごとに距離を更新していく。
    頂点間を結ぶエッジに逆方向へ戻るルートや、どこかでループする閉路がない限り、頂点数Nに対して、辺は高々N-1個になるはず。
    なぜなら、戻る道やループがない限り、同じノードを踏むことはありえない。
    スタート地点をすでに踏んでいることを考えるとルートがmaxになる。

    ・実装的には始点と終点を選んでというより、始点からDFSで進んでいけばよさそうなのはわかる。
    この方針で進めると、閉路や戻る道が存在するとOUTっぽいことは直感的にわかる。
    理論的にはなんとかなりそうだけど、ダメなルートを排除する方針が実装きつそう。
    なので、負閉路とか正閉路とか、無理パターンのグラフが与えられた時には「いっそNGを出しちゃう」という検出結果を与えることにする。
    正閉路に関しては(dist[next],dist[prev])がminに更新されない時点で探索を打ち切ればいいので、最短距離検出には影響なさそう。
    →←みたいな戻り路も同じ理由でおk。というか、これもひとつの閉路。

    →　結局、min更新の障害となりうるのは負閉路が存在するときのみ。

E137の解法2　では、ベルマンフォードを走らせた後に(D[e.to] > D[e.from] + e.cost)を検出すると、D[e.to]をMINFで更新している。
これは、最短を更新しつくした後に、a -> b を見たとき、未だ更新余地がある場合負閉路が存在することに他ならない。
なぜなら、すでに最短ルートが揃っているはずなので、（Bellman_Fordで検出済み）ルートチェックしてみると
・ = 最短
・ > 最短
のどちらかになるはずで、 < 最短　となることはありえない。
つまり、更新予知があるときは、それ以降も無限回更新し続けるので負閉路であるはず。

/*