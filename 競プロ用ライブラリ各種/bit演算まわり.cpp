//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//bit演算
//
    bit演算は整数型intを2進数で考えること。
    たとえば、45 = 0b00101101 となる。
    また、8bitとは上のように、01が8桁使われている表記の事。
    {0,2,3,5}の集合をbitで表すとすると、 00101101 のようにあらわされる。

//AND演算
//
    45 = 0b101101
    25 = 0b011001 なので、
    45 AND 25 = 0b001001 となる。
    つまり、1と1が被ったところが1になり、それ以外は0になるということ。

//OR演算
//
    45 OR 25 = 0b111101 となる。
    1と0も1にする演算。

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//bit_flag集をvectorに格納
//
    vector<int> bit_flag(10);
    rep(i,8){
        bit_flag[i] = (1 << i);
    }
//

//bit を8bit(8桁)で表示
//
    bitset<8>(bit)
//

//bitを複数本立てる(N,M,Lに任意の桁数を入力)
//
    int bit = bit_flag[N] | bit_flag[M] | bit_flag[L];
//

//複数のbit変数の　AND　と　OR　の演算例
//
    cout << "bit & bit2 = " << bitset<8>(bit & bit2) << endl;   //AND
    cout << "bit | bit2 = " << bitset<8>(bit | bit2) << endl;   //OR
//

//bitが立っているかどうかの条件分岐例(AND)
//
    if(bit & bit_flag[5]) //tureでON、falseでOFF, bitの5が立ってるとON

//

//bitが消えているかどうかの条件分岐例(NOT)
//
    if(!(bit & bit_flag[2])) //tureでOFF、falseでON, bitの2が立ってるとOFF
//

//bit変数に追加でフラグを立てる(+=みたいなテンションで | を使ってる)
//
    bit |= bit_flag[6];
//

//bit変数の任意のフラグを折る(~でbitを反転させてる？)
//
    bit &= ~bit_flag[6];
//

//bit変数に何本のフラグが立ってるか（1の数）
//
    int res = __builtin_popcount(bit);      //resに代入している。あと__builtの__は_が二本に注意
//


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//マスクbitとは？
//
//マスクbitとは、一本ずつフラグを立てるのではなく、まとまった本数のフラグをいっぺんに立てたいときに使うbit変数の事。
    ・複数のフラグをまとめて立てる
    ・複数のフラグをまとめて消す
    ・必要な情報だけを取り出すために、マスクした部分の情報のみを取り出す
    ということ。
    基本的には、さっきまでの演算のbit_flag[i]がmask変数に代わるだけ。
//
    使用例:「毒」または「麻痺」かどうかを判定する部分

    if (status & MASK_DOKU_MAHI)

    について、マスクビットを用いないと

    if ((status & BIT_FLAG_DOKU) || (status & BIT_FLAG_MAHI))

    のように書くことになります。マスクビットを用いることでより見やすくなる効果があるのがわかるかと思います (乱用は禁物ですが...)。
//

///////////////////////////////////////////////////
//bitによる集合演算
//

//bitにi番目のフラグが立っているか？
    if(bit & bit_flag[i]) // i ∈ bit  かどうか

//bitにi番目のフラグが消えているか？
    if(!(bit & bit_flag[i])) // i ∉ S かどうか

//bitにi番目のフラグを立てる
    bit |= bit_flag[i] // bit = bit ∪ {i}

//bitのi番目のフラグを消す
    bit &= ~bit_flag[i] // bit = bit - {i}

//bitに何個のフラグが立っているか
    int flag = __builtin_popcount(bit); // bitの要素数

//すべてのフラグが消えている状態
    0 //空集合 ∅

//すべてのフラグが立っている状態
    bit_flag[n] - 1 // {0,1,…,n-1}

//いろいろ
    S & T //S ⋀ T

    S | T //S ∨ T

/////////////////////////////////////////////////


//bit全探索のひな形
//
    int n = 5;
    // {0, 1, ..., n-1} の部分集合の全探索
    for (int bit = 0; bit < (1<<n); ++bit){
        /* bit で表される集合の処理を書く */

    }
//