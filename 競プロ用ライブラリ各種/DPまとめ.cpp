    DP まとめ
//    https://qiita.com/drken/items/dc53c683d6de8aeacf5a        参照

    DP な問題の形式は「最小化問題」「最大化問題」「数え上げ問題」「判定問題」「確率問題」　などがあり、
    このうち最小化問題、最大化問題については特に
        chmin   chmax
    を使う。

    おそらく色んな流儀があると思いますが、

    1   DP 配列全体を「DP の種類に応じた初期値」で初期化
    2   初期条件を入力
    3   ループを回す
    4   テーブルから解を得て出力

    という流れで実装すると上手く行くイメージがあります。
    具体例として、最小化問題であれば以下のような流れが典型的だと思います:

/////////////////////

// 無限大の値
const long long INF = 1LL << 60;

// DP テーブル
long long dp[100010];

// DP テーブル全体を初期化 (最小化問題なので INF に初期化)
for (int i = 0; i < 100010; ++i) dp[i] = INF;

// 初期条件
dp[0] = 0;

// ループ
for (int i = 0; i < N; ++i) {
    chmin(dp[なにか], dp[なにか] + なにか);
    ...
}

// 解を得て出力
cout << dp[N-1] << endl;

////////////////////
基本は上の流れでおｋ


    //貰う DP と配る DP との違い
    DP を書き始めたばかりの頃は、しばしば「貰う DP」と「配る DP」との違いに困惑してしまいます。
    しかし広い目で見るとほとんど一緒で、どちらの方法でも下図のようなグラフのすべての矢印について (矢印の根元を from、先端を to とします)

        chmin(dp[to], dp[from] + (矢印の重み));

    という更新を 11 回ずつ行っています。その更新の順番が違うだけです。
    なおこのような更新のことを専門用語で「緩和」と呼びます。緩和をするという考え方が DP の本質と言えるでしょう。
    最短路アルゴリズムとして知られる Bellman-Ford 法や Dijkstra 法も緩和フレームワークに則ったアルゴリズムなので DP の一種と言えます。

    今回のような DP で重要なことは、「貰う DP」でも「配る DP」でも

       ノード from からノード to への緩和を行うときは、
       dp[from] の値の更新は完了している

    という点です。このルールさえ満たしていれば、どのような順番で緩和を行ってもいいわけです


    //DP の計算量
    DP は特別な最適化がほどこされたものでなければ、計算量の解析はとても簡単です。
    下図のようなグラフの各枝を順に 11 回ずつ緩和していく営みになりますので、計算量は

        O(V+E)　(V は DP テーブルのノード数、E はエッジ数)

    となることがほとんどです。

//C099 - Strange Bank が配るDPを使った類題としてある。

    //Edu DP はA,B,Cを解いて、Cまで解説を読んだ。
